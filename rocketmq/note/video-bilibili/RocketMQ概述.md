# RocketMQ 概述

[本文总结自视频](https://www.bilibili.com/video/BV1cf4y157sz)

## MQ 概述

### MQ 简介

MQ，即 Message Queue，是一种提供消息队列服务的中间件，也称为消息中间件，是一套提供了消息生产、存储、消费全过程 API 的软件系统。消息可以简单认为是数据，一般而言，消息体不会太大。



### MQ 用途

主要分为 异步处理、应用解耦、流量削峰、日志处理、消息通讯 等应用场景。

#### 异步处理

**场景举例**：用户注册后，需要发送注册邮件和注册短信，传统的做法有两种，即串行和并行方式。

**串行方式**：将注册信息写入数据库成功后，发送注册邮件，再发送注册短信，当这三个任务全部完成后，返回结果给客户端。

![异步处理-串行方式](https://images.cnblogs.com/cnblogs_com/parzulpan/1907498/o_210102072809%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E4%B8%B2%E8%A1%8C%E6%96%B9%E5%BC%8F.png)

**并行方式**：将注册信息写入数据库成功后，发送注册邮件的同时，发送注册短信，当这三个任务完成后，返回结果给客户端。与串行的差别是，并行的方式可以提高处理的时间。

![异步处理-并行方式](https://images.cnblogs.com/cnblogs_com/parzulpan/1907498/o_210102072829异步处理并行方式.png)

**引入消息队列后**，将不是必须的业务逻辑，可以异步处理，改造后的架构为：

![异步处理-引入消息队列](https://images.cnblogs.com/cnblogs_com/parzulpan/1907498/o_210102072837%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E5%BC%95%E5%85%A5%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.png)



#### 应用解耦

**场景举例**：用户下单后，订单系统需要通知库存系统。传统的做法是，订单系统调用库存系统的接口，如下图：

![应用解耦-传统做法](https://images.cnblogs.com/cnblogs_com/parzulpan/1907498/o_210102072847%E5%BA%94%E7%94%A8%E8%A7%A3%E8%80%A6%E4%BC%A0%E7%BB%9F%E5%81%9A%E6%B3%95.png)

**传统做法的缺点**：假如库存系统无法访问，或者系统崩了，则订单减库存将失败，从而导致订单失败，订单系统与库存系统耦合严重。

**引入消息队列后**，对于订单系统，用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回用户订单下单成功；对于库存系统，订阅下单的消息，采用**拉/推**的方式，获取下单信息，库存系统根据下单信息，进行库存操作。

![应用解耦-引入消息队列](https://images.cnblogs.com/cnblogs_com/parzulpan/1907498/o_210102072856%E5%BA%94%E7%94%A8%E8%A7%A3%E8%80%A6%E5%BC%95%E5%85%A5%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.png)



#### 流量削峰

**场景举例**：秒杀服务中，一般会因为流量过大，可能导致服务挂掉。为了解决这个问题，一般需要在应用前端加入消息队列。

**引入消息队列后**，可以控制活动的人数，也可以缓解短时间内高流量压垮应用。

![流量削峰-引入消息队列](https://images.cnblogs.com/cnblogs_com/parzulpan/1907498/o_210102072909%E6%B5%81%E9%87%8F%E5%89%8A%E5%B3%B0%E5%BC%95%E5%85%A5%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.png)



#### 日志处理

**场景举例**：分布式系统会产生海量级数据流，例如业务日志、监控数据、用户行为等。日志处理是指将消息队列用在日志处理中，比如Kafka 的应用，解决大量日志传输的问题。

**引入消息队列后**，对于日志采集客户端，负责日志数据采集，定时写入消息队列；对于消息队列，负责日志数据的接收、存储和转发；对于日志处理系统，订阅并消费消息队列中的日志数据。

![日志处理-引入消息队列后](https://images.cnblogs.com/cnblogs_com/parzulpan/1907498/o_210102072920%E6%97%A5%E5%BF%97%E5%A4%84%E7%90%86%E5%BC%95%E5%85%A5%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.png)



#### 消息通讯

**场景举例**：消息队列一般都内置了高效的通信机制，因此也可以用于纯消息通讯，比如实现点对点消息队列，或聊天室等。

**引入消息队列后**，对于点对点通讯，客户端 A 和 客户端 B 使用同一队列，进行消息通讯；

![点对点通讯-引入消息队列后](https://images.cnblogs.com/cnblogs_com/parzulpan/1907498/o_210102072928%E7%82%B9%E5%AF%B9%E7%82%B9%E9%80%9A%E8%AE%AF%E5%BC%95%E5%85%A5%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.png)

对于聊天室通讯，客户端 A、客户端 B ... 客户端 N 订阅同一个主题，进行消息发布和接收。



### 常见 MQ 产品

**ActiveMQ**：是使用 Java 语言开发的一款 MQ 产品，早期很多公司在使用，但是现在社区活跃度很低，实际项目中已经很少使用了。

**RabbitMQ**：是使用 Erlang 语言开发的一款 MQ 产品，其吞吐量较 Kafka 与 RocketMQ 要低，且由于其不是 Java 语言开发，公司内部对其实现定制化开发难度较大。

**Kafka**：是使用 Java/Scala 语言开发的一款 MQ 产品，其最大的特点就是高吞吐率/量，常用于大数据领域的实时计算、日志采集等场景。它没有遵循常见的 MQ 协议，而是使用自研协议。

**RocketMQ**：是使用 Java 语言开发的一款 MQ 产品，其最大的特点是性能强悍稳定性高。它也没有遵循常见的 MQ 协议，而是使用自研协议。



### 常见 MQ 协议

一般情况下，MQ 的实现要遵循一些常规性的协议，常见的 MQ 协议：

**JMS**，Java Messaging Service，Java 消息服务，是 Java 平台上有关 **MOM**(Mesage Oriented Middleware，面向消息的中间件) 的技术规范，它便于消息系统的 Java 应用进行消息交换，并且通过提供标准的产生、发送、接收消息的接口，简化企业应用的开发。ActiveMQ 是该协议的典型实现。

**STOMP**，Streaming Text Orientated Message Protocol，面向流文本的消息协议，是一种 MOM 设计的简单文本协议。STOMP 提供一个可交互操作的连接格式，允许客户端与任意 STOMP 消息代理(Broker) 进行交互。ActiveMQ 是该协议的典型实现，RabbitMQ 通过插件可以支持该协议。

**AMQP**，Advanced Message Queuing Protocol，高级消息队列协议，一个提供统一消息服务的应用层标准，是应用层协议的一个开放标准，是一种 MQM 设计。基于此协议的客户端与消息中间件可以传递消息，并不限制客户端/中间件产品和开发语言。RabbitMQ 是该协议的典型实现。

**MQTT**，Message Queuing Telemetry Transport，消息队列遥测传输，是 IBM 开发的一个即时通讯协议，是一种二进制协议，主要用来服务器和低功耗 IoT 设备间的通信。该协议支持所有平台，几乎可以把所有联网物品和外部连接起来，被用来当作传感器和致动器的通信协议。RabbitMQ 通过插件可以支持该协议。



## RocketMQ 概述

详情请参考官网，吐槽一句，官网文档好久没更新了！



## 总结

